During the CTF the first this we are given is a wireshark capture packet and I immediately open wire shark and follow the TCP stream to see what I can find. I noticed there was a whole program sent over the network so i downloaded that as raw and started putting it through ghidra to see what I could find. I found that it takes a few inputs at the start and I wanted to know where it was getting it's inputs from. I noticed that in the wireshark packets there was data being sent to the server with the same parameters that program was asking like the input from the buffer starting with a "F", "P", or "S". This is important because anything that follows the buffer is plaintext we have access to now. For example we notice that if we enter in the letter "P" for buff[0] we will set our key and so what this means if we follow our code the next 16 bytes of data in the buffer are what our key to the AES encryption will be. We now have our flag and know how the program operates we need to know what happens after the "S" escape character is used to stop inputting data but not to encrypt and return it to us. We are given two 16 byte hex data and we know this is the encrypted data because inspecting the code we find that after it encrypts 16 bytes it send it to the client and keeps encrypting until there is not more data left in the file. During the encryption process before it is passed into the function AES_encrypt it goes through a small for look that just scrambles the data by XORing it a few times with it's neighboring data. Now that we have all of this information we are given the key, the encrypted data, and how it was encrypted before the AES encryption so we just need to do the reverse steps. first we run it through a python script to decrypt the AES and then we do the reverse of the for loop they did in the code to decrypt the XORs. after we finis decrypting we are left with the flag split into two parts.

Flag: flag{CATS_CATS_ARE_NICE}
