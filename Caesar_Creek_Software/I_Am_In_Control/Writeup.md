For this challenge I first started putting the code into ghidra to disassemble it. The extracted code in ghidra was very stripped and I was only able to locate pointers throughout the code that didn't really tell me that much. I then started trying to find an emulator that could run the Sega Genesis ROM. I wanted some debugging features where I could look at the values in registers and in memory to find more about the system. The first emulator I managed to find was MAME. MAME has a lot of debugging support where I could trace the code, set break/watch points, and very importantly you could run and interact with the program. I noticed that when you click the screen, press '1', or press the space bar all  would print a string on the screen. My first approach was to find what code was interacting with these inputs. Where was the text being printed. I first traced the code and spammed a bunch of inputs because I wanted to see what was different in execution from no inputs to a lot of them. Once i found which code was actually printing those strings I wanted to analyze it more. I noticed something interesting about that code that each int it moved into the 0xc0000 memory location was mapped somewhere to its own character. 

After finding out that these characters were all mapped to some value I didn't really find out anything else but at the end of the last strings memory section was called it would return using a 'rts' operation. The next section of the code after that 'rts' operation was another section that looked similar but it was loading a value from memory into the program. I decided to look back at ghidra and see if there anything that looked suspicious or would stand out. I managed to find something but it was not at that address it was right before that address was mentioned it has a very peculiar string that has hex values all separated by a '1a'. What I also thought was interesting was that the characters were similarly spaced apart if they were the hex values for 'flag{' they resembled something similar but not exact so I knew that this was my area I was looking for.

One of the next things I noticed was that one of the lines that SHODAN would output was "DONT BOTHER WITH THE SPRITE COORDINATES YOU CANT STOP ME THERE" This stuck out to me because what is the need to mention the coordinates. I was not able to get any information about graphics debugging in MAME so I went to find another emulator that would give me more information on the actual graphics of the game. I found another emulator Exodus. This emulator has a lot of functionality for graphical debugging and allows you to see multiple different regions on memory including ROM, RAM, and VRAM. It even allows you to modify them. Exodus also gave me a Sprite List and also a VDP Pattern Viewer. These were really important for solving this ctf because the Sprite List gave me the coordinates of the sprite.

After I know the coordinates of the sprite I was trying to find out where to change those values are so I could modify them and see how the program reacts. I want to take a step back to that flag like sequence I found earlier. I wanted to see if that code is ever referenced and so I used ghidra to search for that memory address and I found one instance of it so I went and set a break point at that part of the code and the code never stopped at my break point. My solution was to change one of the 'rts' operations to a 'nop' which would continue the flow of the code until it reaches another 'rts'. This let me see what running those instructions would give me and the first thing I saw was it loaded some values from RAM into the registers and OR'd those two values. The two values it was ORing were the coordinates of the sprite. It was grabbing those coordinates from RAM so I didn't even need to find where to manually set them I could just modify the ran at a breakpoint and continue execution. This new value that comes from those coordinates and it used in comparison operations which were the values that were loaded from the flag's memory location. It loaded two bytes at a time and XOR'd those two bytes with the OR'd coordinate values and compared the first two bytes with the value 0x6363 and the second two bytes with the value 0x7377. It was a simple XOR between the wanted values and the values loaded to figure out what value I needed my coordinates to be. The value I needed to XOR them with was 0x188e.

So after changing the 'rts' op to a 'nop' I set a break point at the 'nop'. Once the program stopped at my break point I went to work and I changed the value in the RAM which were the X cord and Y cord to their new values. After the values were changed I let the program run again and it gave me the flag.
